> ### map和slice及数组都不是线程安全的，多线程访问时记得加锁

# 1.默认切片的容量问题？
```go
var p []int //这样的代码等于
make([]int,0,8) //扩容长度为8，初始大小为0
```

# 2.切片扩容后原始切片是被丢失还是和扩容后的一段组合？
```go
    var p = make([]int,0,1)
    p = append(p,0)
    p = append(p,1)
```
[文章](https://studygolang.com/articles/26738?fr=sidebar)

    那么第一次append时的数组会和第二次append扩容后的数组进行合并还是第二次扩容后产生的是全新数组呢，即内存中
    是 [1]{0} 还是[2]{0,1} 同时存在还是只存在[2]{0,1}?

    答案是只存在[2]{0,1} , [0]{1} 已经被标记为垃圾等待回收
    
    
    
# 3. slice扩容长度 
    如果插入的下标超过1023,则扩容的大小等于 slice的当前长度+=长度 即m+=m,算是翻倍吧。当插入的下标大于1023则扩容等于当前容量/4，即25%，也就是m+=m/4。这些设定详细鉴于go源码的grow函数