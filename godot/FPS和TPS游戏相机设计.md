```txt
故事要从2015年开始说起，那一年出于兴趣编写了 https://github.com/hakur/shooter 这个fps游戏demo。

现在总结一看当初在unity上的fps游戏相机设计，同时也聊一聊在godot上要怎么做。

包含 相机旋转、移动、后坐力导致的上扬以及后坐力镜头恢复，本文只将设计逻辑，不讲代码。本文的unity3d基于5.3(因为我2016年之后没有继续学习unity3d了)，godot 4.0(2022年重燃游戏的兴趣)
```


### FPS 第一人称射击游戏相机篇：
首先，在unity3d中相机存在一个属性叫做 Culling Mask ，这个属性决定了相机可以拍摄哪一层的图像，而在godot中相机(Camera3D)也有一个属性 Cull Mask。

为什么要讲这个属性呢，因为FPS游戏有枪械，如果让武器模型靠近墙壁则会出现武器模型和墙壁穿模的情况。

为了解决穿模问题，也为了方便后续的镜头后坐力逻辑的编写。需要建立两个相机分别用于拍摄 世界层和武器层。世界层就是能看到的地图模型还有其他玩家，而武器层就是FPS游戏的手臂和武器图像了。

他们的层级结构如下：
```
PlayerNode (玩家节点，负责带着两个相机做世界坐标更新)
|_ WorldCameraNode (世界层相机，负责鼠标滑动后的视野旋转)
    |_ WeaponCameraNode (武器层相机，负责武器开火时后坐力逻辑)
```
我们假设 WorldCameraNode 的 Cull Mask 值为 1 ，武器的WeaponCameraNode的 CullMask 值为 2。这样 WorldCameraNod 将不会拍摄武器，WeaponCameraNod 将不会拍摄世界图像。
* #### 移动
    当玩家移动时，将会带动两个相机一起移动，因为两个相机是玩家节点的子节点。

* #### 后坐力逻辑
    接下来讲一下后坐力逻辑，假如世界坐标是 左右为X轴，上下位Y轴，前后为Z轴。

    当玩家的武器开火时，将需要增加后坐力，这时将在Update()函数中(godot 是 _process函数) WeaponCameraNode 的 X轴 往上旋转，假如网上旋转 2 度。那么在FixedUpdate()函数(在godot中是 _physics_process) 中将 X 轴往下旋转 1 度来构成后坐力恢复效果，毕竟玩家停止开火后需要将镜头修正，或者玩家使用点射的方式开火，这期间借助于后坐力恢复镜头逻辑也可以给玩家带来较好的游戏体验。

* #### 鼠标镜头旋转控制
    最后再聊一聊镜头旋转的事情，假如世界坐标是 左右为X轴，上下位Y轴，前后为Z轴。

    使用Input的函数去读取鼠标是的往左还是往右，往前还是往后。将鼠标的移动方向转化为绝对值，也就是 -1 和 1，当鼠标移动为0时就意味着鼠标没有洞，当然也要考虑给玩家增加一个选项，就是鼠标抖动灵敏值，当一个鼠标损坏的时候，可能会莫名奇妙地触发移动输入，这个值非常微小，最好是当鼠标移动的距离大于多少时才执行将鼠标移动距离转换为绝对值。当然这个阈值可以是玩家自己填写也可以是开发者自己做一个黑盒子式的勾选框。

    当鼠标左右移动得到-1时，意味着往左滑动，那么此时应当将 WorldCameraNode 的Y轴往左旋转，反之如果鼠标移动得到的绝对值是1那就是Y轴就是往右旋转。

    当鼠标前后（也可以叫上下）移动得到-1时，那么此时应当将 WorldCameraNode 的X轴往下旋转，反之如果鼠标移动得到的绝对值是1那就是X轴就是往上旋转。

### TPS 第三人称射击游戏相机篇：
可能有些读者不愿意将上面的FPS相机的内容读完整，因此这里复制了一些通用逻辑。

首先，在unity3d中相机存在一个属性叫做 Culling Mask ，这个属性决定了相机可以拍摄哪一层的图像，而在godot中相机(Camera3D)也有一个属性 Cull Mask。

在上面的FPS游戏相机设计中，为了解决穿模使用了两个相机，而TPS第三人称射击游戏中不存在这样的穿模逻辑。因此只需要设计一个相机就可以了。但是为了优雅地实现后坐力逻辑，仍然采用后坐力节点和鼠标滑动节点分离的设计。

他们的层级结构如下：
```
PlayerNode (玩家节点，负责带着两个相机做世界坐标更新)
|_ TPSCameraControlNode (空的3D节点，负责鼠标滑动后的视野旋转)
    |_ Camera3DNode (世界和角色相机，负责武器开火时后坐力逻辑)
```

* #### 移动
    当玩家移动时，将会带动 TPSCameraControlNode 和 Camera3DNode 一起移动，因为两个节点是玩家节点的子节点。

* #### 后坐力逻辑
    接下来讲一下后坐力逻辑，假如世界坐标是 左右为X轴，上下位Y轴，前后为Z轴。

    当玩家的武器开火时，将需要增加后坐力，这时将在Update()函数中(godot 是 _process函数) Camera3DNode 的 X轴 往上旋转，假如网上旋转 2 度。那么在FixedUpdate()函数(在godot中是 _physics_process) 中将 X 轴往下旋转 1 度来构成后坐力恢复效果，毕竟玩家停止开火后需要将镜头修正，或者玩家使用点射的方式开火，这期间借助于后坐力恢复镜头逻辑也可以给玩家带来较好的游戏体验。

    这里不要为此赶到困惑，因为玩家能看到的东西其实是 TPSCameraControlNode 的旋转加上 Camera3DNode 的旋转的结果，当 Camera3DNode 因为后坐力镜头恢复而变得正常时，将只会剩下 TPSCameraControlNode 的旋转。

* #### 鼠标镜头旋转控制
再聊一聊镜头旋转的事情，假如世界坐标是 左右为X轴，上下位Y轴，前后为Z轴。

使用Input的函数去读取鼠标是的往左还是往右，往前还是往后。将鼠标的移动方向转化为绝对值，也就是 -1 和 1，当鼠标移动为0时就意味着鼠标没有洞，当然也要考虑给玩家增加一个选项，就是鼠标抖动灵敏值，当一个鼠标损坏的时候，可能会莫名奇妙地触发移动输入，这个值非常微小，最好是当鼠标移动的距离大于多少时才执行将鼠标移动距离转换为绝对值。当然这个阈值可以是玩家自己填写也可以是开发者自己做一个黑盒子式的勾选框。

当鼠标左右移动得到-1时，意味着往左滑动，那么此时应当将 TPSCameraControlNode 的Y轴往左旋转，反之如果鼠标移动得到的绝对值是1那就是Y轴就是往右旋转。

当鼠标前后（也可以叫上下）移动得到-1时，那么此时应当将 TPSCameraControlNode 的X轴往下旋转，反之如果鼠标移动得到的绝对值是1那就是X轴就是往上旋转。

* #### 鼠标滚轮控制镜头距离
    建立镜头距离 最近、最远、默认、鼠标滚轮一次输入移动距离 四个变量值。
    鼠标滚轮输入绝对值来判断 Camera3DNode 相对于父节点 TPSCameraControlNode 的z轴是需要减少还是增加。
* #### 瞄准
    瞄准我使用的不是改变镜头FOV，而是拉进镜头距离，这是一个额外的变量 aim_distance_factor。瞄准时他的值假设 为 -4 ，让 Camera3DNode 的z轴距离减少4个单位（注意平滑），非瞄准状态该变量为0，也就是 Camera3DNode的相对父节点的z轴距离 += aim_distance_factor即可

    最后我很讨厌TPS瞄准时只能看后背的设计，TPS游戏瞄准时应当让玩家看角色模型的正面才是好的设计。也就是模型角色侧身站着瞄准。

* #### 左右肩膀视角
    默认中间视角，左右肩膀视角实际上是改变 Camera3DNode 相对于父节点的x轴的值是负数还是正数来实现的，如果x轴为负数就表示左肩膀，假如左肩膀需要的值为 -10 个单位，右肩膀可能需要的值为 10 个单位，而中间视角则重置 Camera3DNode相对于父节点的 x轴距离。
